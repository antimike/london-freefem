// Vector potential created by an infinite superconducting wire 
// Solved using either the "problem" keyword, or manipulating the stiffness matrix. 
// Bondary conditions at large distance being non-zero, a current must circulate
// Where Laplace(Az) is not 0, i.e. in the wire
// "boxoice" parameter controls whether we use a space with rectangular or cylindrical section. 
///////////////Define geometry/////////////////////////////// 
// linear dimensions (in Âµm)
// Penetration depth (squared)
real tgv=1E30, epsi=1E-6, xi,yi, Lond=0.2, l2= Lond^2; // Lambda_London =0.2 um
real mu0s2p = 2e-7, mu0=mu0s2p*2*pi, I1=1, A0=mu0s2p*I1; // for current I1=1 Amp.
// Rectangular Section: Choice 1
real far=20,high=20; 
border bottom(t=-far,far) { x=t; y=-high; label=1; }
border rside(t=-high,high) { x=far; y=t; label=1; }
border lside(t=high,-high) { x=-far; y=t; label=1; }
border top(t=far,-far) { x=t; y=high; label=1; }

// Cylindrical section: Choice 2
real RB=23;  // RB is the radius of the box
border RoundBox(t=0,2*pi) { x=RB*cos(t); y=RB*sin(t); label=2; }

int boxoice= 2, prost=1; // boxoice: choice of outer box shape; prost: 0 for "problem"; 1 for "stiffness"


// Wire
real R=1;  // R is the radius of the wire
border wire(t=0,2*pi) { x=R*cos(t); y=R*sin(t); label=3; }
border bulk(t=0,2*pi) { x=(R-2*Lond)*cos(t); y=(R-2*Lond)*sin(t); label=4; }
/////////////////////////////////////////////////////////////
//////////// Mesh and London equation ///////////////////////
int NBM=50, NBW=200;
mesh Th;
if ( boxoice==1 ) Th=buildmesh(bottom(NBM)+rside(NBM)+top(NBM)+lside(NBM)+wire(NBW)+bulk(NBW));
if ( boxoice==2 ) Th=buildmesh(RoundBox(3*NBM)+wire(NBW)+bulk(NBW));
// regions are numbered 0 , 1 and 2
int core=Th(0,0).region, super=Th(R-Lond,0).region, air=Th(R+Lond,0).region;
cout << "Superc. regions: " << core <<" and "<< super << ", and air: "<< air<< endl;

fespace Vh(Th,P2); // With P1, the result would be very noisy...
Vh Az, v, u0, ubc;
int nbvertices=Th.nv, NDF=Vh.ndof; 

// The  following lines give analytically exact BC for single cylindrical wire 
if ( boxoice==1 ) { 
	u0 =(abs(abs(x)-far)<1E-2 || abs(abs(y)-high)<1E-2) ? A0/2*log(x^2 +y^2):0; // for rectangular box
};
if ( boxoice==2 ) { 
	u0 =(abs(x^2+y^2-RB^2)<epsi) ?      A0*log(RB):0; // for disk box
};
ubc=(u0==0) ? 0: tgv*u0; // This was to avoid 0*1E30, but it does not seem necessary ...

fespace W0(Th,P0);
W0 Sup=(region==super || region==core); // Size(Sup)=nb of TRIANGLES !!!
W0 Cor=(region==core); 
cout << "Nb Vert.="<< nbvertices<<", NDoF="<< NDF<< ", size(Sup)=" << Sup.n << endl;
func fL=-Sup/l2; // For London equation in the superconductor
///////////////////////////////////////////////////
//////////// Solve problem  ///////////////////////
problem poissonMagneto(Az,v) =
  int2d(Th)( dx(Az)*dx(v) + dy(Az)*dy(v) ) 
 + int2d(Th) ( -v*Az*fL ) // the source term: Mu0*J=-Az/Lond^2 in the superconductor
 + on(boxoice, Az=u0);	// boundary condition far away: Az=mu0s2p*I1*log(r)

varf va(Az,v) =                    //  definition of the problem 
   	int2d(Th)( dx(Az)*dx(v) + dy(Az)*dy(v))
	+ int2d(Th) ( -v*Az*fL ) // the source term: Mu0*J=-Az/l2 in the superconductor
	+ on(boxoice,Az=u0);
matrix A=va(Vh,Vh);				
real[int] F=ubc[];

if (prost==0) {poissonMagneto;} 
else {
	set(A,solver=UMFPACK); 
	Az[]=A^-1*F; // solve the linear system
}; // prost==1 seems to be slightly faster; otherwise, both methods give the same results.

////////////////////////////////////////////////////
//////////// Display results ///////////////////////

plot(Th,ps="wire.eps",bw=1, wait=true, cmm="Mesh"); 

Vh Bx = -dy(Az)(x,y), By = dx(Az)(x,y);
Vh Jz = (dx(By)-dy(Bx))/mu0; 
string Title="Contour plot of Az, ";
if (prost==0) Title=Title+"Solve"; else Title=Title+"Stiffness";
plot(Az, ps="vector_potential_wire.eps", value=true, wait=true, cmm=Title);
Title="Contour plot of Jz, ";
if (prost==0) Title=Title+"Solve"; else Title=Title+"Stiffness";
plot(Jz, ps="Current_density_wire.eps", value=true, wait=true, cmm=Title);
// Larger values of the current are indeed obtained for the surface of the wire, 
cout << "Core current =" << int2d(Th)(Cor*Jz) << endl; // 9% of the current in the core
// No negative values in the core, as expected
// Check total current: integrates the current density in the wire =I1
cout << "Total current =" << int2d(Th)(Jz) << " and Wire current =" << int2d(Th)(Sup*Jz) << endl; 
// The integrated current density is about 10% too small

// Using Gauss theorem, calculate By(R,0)=mu0s2p*I1/R, i.e. mu0s2p*I1=R*By(R,0)
cout << "Apply Gauss theorem at r=2*R: I1="<< 2*R*By(2*R,0)/mu0s2p << endl;
// The value of the field is also too small (about -7%). Does not seem to depend on the mesh... ???
cout << "Apply Gauss theorem at r=20*R: I1="<< 20*R*By(20*R,0)/mu0s2p << endl;
// Here also, By is too small (-9%).

